<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Recursive Meta-Querying: Query-based Metadata Extraction for Querying over Hypermedia-based Linked Datasources</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css" />
  <link rel="stylesheet" media="print"  href="styles/print.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  
  <meta name="citation_title" content="Recursive Meta-Querying:<br />Query-based Metadata Extraction for Querying over Hypermedia-based Linked Datasources">
  <meta name="citation_author" content="Ruben Taelman" />
  <meta name="citation_author" content="Miel Vander Sande" />
  <meta name="citation_author" content="Ruben Verborgh" />
  
  <meta name="citation_publication_date" content="2019/06/28" />
</head>

<body prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio# as: https://www.w3.org/ns/activitystreams# oa: http://www.w3.org/ns/oa# ldp: http://www.w3.org/ns/ldp#" typeof="schema:CreativeWork sioc:Post prov:Entity">
  <header>
  <h1 id="recursive-meta-queryingbr-query-based-metadata-extraction-for-querying-over-hypermedia-based-linked-datasources">Recursive Meta-Querying:<br />Query-based Metadata Extraction for Querying over Hypermedia-based Linked Datasources</h1>

  <!--{:#authors}
- <a href="http://www.rubensworks.net/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
- <a href="#" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/miel_vander_sande">Miel Vander Sande</a>
- <a href="https://ruben.verborgh.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>

{:#affiliations}
- {:#idlab} IDLab,
            Department of Electronics and Information Systems,
Ghent University – imec-->

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>Linked Datasources can be exposed through hypermedia-based interfaces such as Triple Pattern Fragments.
When intelligent clients query over such interfaces,
they need to detect controls from within the metadata.
<!-- Need         -->
This detection typically happens by manually iterating over the RDF triples,
which is hard to implement for complex control shapes.
<!-- Task         -->
Since hypermedia-based query engines already have querying capabilities at their disposal,
this <em>extraction</em> process can be simplified through a <em>single declarative query</em>.
<!-- Object       -->
In this article, we implement and test this simplification using GraphQL-LD queries.
<!-- Findings     -->
We show that this <em>query-based</em> metadata extraction process reduces implementation effort
at the cost of query execution time overhead.
<!-- Conclusion   -->
As such, there is a <em>trade-off</em> between <em>development</em> efficiency and <em>execution</em> efficiency.
<!-- Perspectives --></p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>

    <p>Linked Data is published via different kinds of Web interfaces,
such as SPARQL endpoints,
Linked Data documents,
or <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2016.03.003"><a href="http://linkeddatafragments.org/publications/jws2016.pdf">Triple Pattern Fragments (TPF)</a></span> <span class="references">[<a href="#ref-1">1</a>]</span>.</p>

    <p>TPF is a <em>self-descriptive</em> hypermedia interface
that exposes <em>metadata</em> to allow intelligent clients to detect how the interface can be used.
TPF metadata contains a triple pattern query form
that is described with the Hydra Core vocabulary <span class="references">[<a href="#ref-2">2</a>]</span> in RDF.
Intelligent hypermedia-based clients such as <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Resource/">Comunica</a> <span class="references">[<a href="#ref-3">3</a>]</span>
are able to detect and interpret this metadata
to enable SPARQL queries over one or more TPF interfaces.
For this, the client splits up the SPARQL query into multiple triple pattern queries,
that are then executed by the TPF interface, and joined client-side.</p>

    <p>Hypermedia-based clients extract metadata
by iterating over triples in the HTTP response and matching specific predicates,
which is hard to implement for complex metadata shapes.
This <em>ad hoc metadata extraction</em> is essentially a manual querying process.
Since we are using a hypermedia-based query engine,
its querying capabilities could be reused to achieve <em>query-based metadata extraction</em>.
Instead of manually implementing logic to extract metadata,
this logic can be replaced with a single query.</p>

    <p>In this article, we discuss the ad hoc metadata extraction process
within the Comunica query engine in <a href="#adhoc_metadata_extraction">Section 2</a>.
After that, we introduce a query-based metadata extraction process for Comunica in <a href="#querybased_metadata_extraction">Section 3</a>.
Finally, we conclude in <a href="#conclusions">Section 4</a>.</p>

  </section>

  <section id="adhoc_metadata_extraction">
    <h2>Ad hoc Metadata Extraction</h2>

    <p>In order to enable querying over TPF interfaces,
the Comunica query engine detects and extracts metadata from RDF responses through two modules,
which will be discussed in more detailed hereafter:</p>

    <ul>
      <li><a href="https://github.com/comunica/comunica/tree/master/packages/actor-rdf-metadata-extract-hydra-count"><strong>Hydra Count Extractor</strong></a>: Extracts cardinality estimates.</li>
      <li><a href="https://github.com/comunica/comunica/tree/master/packages/actor-rdf-metadata-extract-hydra-controls"><strong>Hydra Controls Extractor</strong></a>: Extracts URL templates with variable mappings.</li>
    </ul>

    <h3 id="hydra-count-extractor">Hydra Count Extractor</h3>

    <p>TPF interfaces expose cardinality estimates for the current fragment via the <code>hydra:totalItems</code> predicate.
This allows client-side engines to determine an efficient join order between the different triple patterns of a SPARQL query.
<a href="#data-count">Listing 1</a> shows an example of this count metadata.</p>

    <p>Due to the simplicity of this data shape,
the Hydra Count Extractor module simply iterates over the triples,
and finds the cardinality in the triple object
once the <code>hydra:totalItems</code> predicate is found.
This implementation can be found on <a href="https://github.com/comunica/comunica/blob/master/packages/actor-rdf-metadata-extract-hydra-count/lib/ActorRdfMetadataExtractHydraCount.ts" class="mandatory" data-link-text="https:/​/​github.com/​comunica/​comunica/​blob/​master/​packages/​actor-​rdf-​metadata-​extract-​hydra-​count/​lib/​ActorRdfMetadataExtractHydraCount.ts">GitHub</a>.</p>

    <figure id="data-count" class="listing">
<pre><code>@prefix hydra: &lt;http://www.w3.org/ns/hydra/core#&gt;.
</code><code>&lt;http://fragments.dbpedia.org/2016-04/en&gt;
</code><code>  hydra:totalItems &quot;1040358853&quot;^^xsd:integer.</code></pre>
<figcaption>
        <p><span class="label">Listing 1:</span> Part of the metadata from http://fragments.dbpedia.org/2016-04/en in TriG
that declares the cardinality estimate with the <code>hydra:totalItems</code> predicate.</p>
      </figcaption>
</figure>

    <h3 id="hydra-controls-extractor">Hydra Controls Extractor</h3>

    <p>TPF interfaces expose their triple pattern search form via <a href="http://www.hydra-cg.com/spec/latest/core/#templated-links" class="mandatory" data-link-text="http:/​/​www.hydra-​cg.com/​spec/​latest/​core/​#templated-​links">Hydra templated links</a>.
This allows client-side engines to determine what kind of queries can be sent to the interface (triple pattern queries in this case),
and how the query should be encoded into the URL.
<a href="#data-templatedlinks">Listing 2</a> shows an example of this templated link metadata.</p>

    <figure id="data-templatedlinks" class="listing">
<pre><code>@prefix void: &lt;http://rdfs.org/ns/void#&gt;.
</code><code>&lt;http://fragments.dbpedia.org/2016-04/en#dataset&gt;
</code><code>  void:subset &lt;http://fragments.dbpedia.org/2016-04/en&gt;;
</code><code>  hydra:search [ hydra:template
</code><code>&quot;http://fragments.dbpedia.org/2016-04/en{?subject,predicate,object}&quot;;
</code><code>  hydra:mapping [ hydra:variable &quot;subject&quot;;
</code><code>                  hydra:property rdf:subject ]
</code><code>              , [ hydra:variable &quot;predicate&quot;;
</code><code>                   hydra:property rdf:predicate ]
</code><code>              , [ hydra:variable &quot;object&quot;;
</code><code>                  hydra:property rdf:object ]. ].</code></pre>
<figcaption>
        <p><span class="label">Listing 2:</span> Part of the metadata from http://fragments.dbpedia.org/2016-04/en in TriG
that declares the Hydra templated link to execute a triple pattern query.</p>
      </figcaption>
</figure>

    <p>This data shape is significantly more complex than the one for counts.
That is why the Hydra Controls Extractor module consists of a non-trivial implementation.
This module iterates over the triples, and detects all predicates that start with the <code>hydra:</code> prefix.
For all triples with Hydra predicates, an in-memory triple index is maintained in the order of <em>predicate</em>, <em>subject</em>, <em>object</em>.
Once all triples have been read, the index is read to find all objects for the <code>hydra:search</code> predicate,
which gives us all search form identifiers.
Next, the index is traversed for all <code>hydra:mapping</code> predicates and search form identifies as subjects,
to find all mapping identifiers for each search form.
Next, for each mapping, the index is traversed for <code>hydra:variable</code> and <code>hydra:property</code> predicates with mapping identifiers as subjects,
to find their respective values.
Finally, all discovered values are collected and saved in a convenient search form datastructure
that can be used by other modules in the further querying process.
This implementation can be found on <a href="https://github.com/comunica/comunica/blob/master/packages/actor-rdf-metadata-extract-hydra-controls/lib/ActorRdfMetadataExtractHydraControls.ts" class="mandatory" data-link-text="https:/​/​github.com/​comunica/​comunica/​blob/​master/​packages/​actor-​rdf-​metadata-​extract-​hydra-​controls/​lib/​ActorRdfMetadataExtractHydraControls.ts">GitHub</a>.</p>

  </section>

  <section id="querybased_metadata_extraction">
    <h2>Query-based Metadata Extraction</h2>

    <p>Due to the complexity of ad hoc metadata extraction,
we introduce a query-based metadata extraction process inside the Comunica query engine.
We write the queries using <a property="schema:citation http://purl.org/spar/cito/cites" href="https://comunica.github.io/Article-ISWC2018-Demo-GraphQlLD/">GraphQL-LD</a> <span class="references">[<a href="#ref-4">4</a>]</span> instead of SPARQL because:</p>

    <ol>
      <li>Queries are <em>compact</em> because <em>IRIs are hidden</em> behind a JSON-LD context.</li>
      <li>Results corresponds to <em>query shape</em>, removing the need for <em>post-processing</em>.</li>
    </ol>

    <p><a href="#query-count">Listing 4</a> and <a href="#query-templatedlinks">Listing 5</a> show the
GraphQL-LD queries that respectively achieve the same task as
the Hydra Count Extractor and Hydra Controls Extractor modules in Comunica.
<a href="#query-context">Listing 3</a> shows the JSON-LD context to expand query terms to IRIs.</p>

    <p>Both queries are precompiled to reduce runtime overhead as much as possible.
Before query execution, the <code>$pageUrl</code> variables in these queries are bound to the actual TPF page URL that is being requested,
so that the proper metadata will be extracted.
In order to execute the queries, a temporary in-memory indexed triple store is created
over which Comunica is able to execute these GraphQL-LD queries.
Since the query shape directly corresponds to the data shape that is expected within Comunica’s metadata datastructure,
minimal post-processing is needed once the results are available.
Furthermore, since GraphQL-LD exploits JSON-LD’s <code>@type</code> feature for mapping RDF literal datatypes to JavaScript primitives,
we don’t need to manually transform between datatypes for fields such as the numerical <code>totalItems</code>.</p>

    <p>The implementation of these query-based metadata extraction module can be found on <a href="https://github.com/comunica/comunica/blob/refactor/metadata/packages/" class="mandatory" data-link-text="https:/​/​github.com/​comunica/​comunica/​blob/​refactor/​metadata/​packages/​">GitHub</a> in the <code>actor-rdf-metadata-extract-hydra-count-query</code> and <code>actor-rdf-metadata-extract-hydra-controls-query</code> packages.</p>

    <figure id="query-context" class="listing">
<pre><code>{ &quot;@context&quot;: {
</code><code>    &quot;@vocab&quot;: &quot;http://www.w3.org/ns/hydra/core#&quot;,
</code><code>    &quot;void&quot;: &quot;http://rdfs.org/ns/void#&quot;,
</code><code>    &quot;xsd&quot;: &quot;http://www.w3.org/2001/XMLSchema#&quot;,
</code><code>    &quot;totalItems&quot;: { &quot;@type&quot;:&quot;xsd:integer&quot; },
</code><code>    &quot;subset&quot;: &quot;void:subset&quot; } }
</code></pre>
<figcaption>
        <p><span class="label">Listing 3:</span> JSON-LD context for expanding terms in GraphQL-LD queries.</p>
      </figcaption>
</figure>

    <div>
<figure id="query-count" class="listing" style="width: 40%; display: block-inline; float: left">
<pre><code>query($pageUrl: String) {
</code><code>  id(_: $pageUrl)
</code><code>  totalItems
</code><code>}</code></pre>
<figcaption>
          <p><span class="label">Listing 4:</span> GraphQL-LD query for extracting cardinality estimates.</p>
        </figcaption>
</figure>

<figure id="query-templatedlinks" class="listing" style="width: 40%; display: block-inline; float: right">
<pre><code>query($pageUrl: String) {
</code><code>  subset(_: $pageUrl)
</code><code>  search {
</code><code>    template
</code><code>    mapping @optional {
</code><code>      variable property
</code><code>  }}}</code></pre>
<figcaption>
          <p><span class="label">Listing 5:</span> GraphQL-LD query for extracting templated links.</p>
        </figcaption>
</figure>

<br style="clear: both" />
</div>

  </section>

  <section id="conclusions">
    <h2>Conclusions</h2>

    <p>Clients that enable querying over hypermedia interfaces such as TPF
require metadata <em>detection</em>, <em>extraction</em>, and <em>shaping</em>.
Ad hoc metadata extraction performs each of these steps separately,
while query-based metadata extraction allows these steps to be performed
by recursively invoking the query engine on a subset of the RDF response.</p>

    <p>Moving from ad hoc metadata extraction towards a query-based metadata extraction
comes with the main advantage that the implementation of the extraction modules
is significantly less complex, which lowers implementation effort.
However, preliminary evaluation shows that query-based metadata extraction introduces a 10~20% overhead
compared to ad hoc metadata extraction in Comunica.
The main bottleneck lies within the recursive invocation of Comunica.</p>

    <p>Our preliminary results shows that abstraction comes at the cost of reduced performance,
so there is a trade-off between development efficiency and execution efficiency.
Since Comunica’s main purpose is <em>flexibility</em>, and not <em>efficiency</em>, reduced performance is not a problem.
Nevertheless, both the query-based and ad hoc modules are available,
where the former can be used for quick prototyping when performance is less important,
and the latter can be used in performance-sensitive environments.</p>

  </section>

</main>

<footer><section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2016.03.003" typeof="schema:Article">Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. (2016).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="#hydra" typeof="schema:Article">Lanthaler, M., Gütl, C.: Hydra: A Vocabulary for Hypermedia-Driven Web APIs. LDOW. 996, (2013).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Resource/" typeof="schema:Article">Taelman, R., Van Herwegen, J., Vander Sande, M., Verborgh, R.: Comunica: a Modular SPARQL Query Engine for the Web. In: Proceedings of the 17th International Semantic Web Conference (2018).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="https://comunica.github.io/Article-ISWC2018-Demo-GraphQlLD/" typeof="schema:Article">Taelman, R., Vander Sande, M., Verborgh, R.: GraphQL-LD: Linked Data Querying with GraphQL. In: Proceedings of the 17th International Semantic Web Conference: Posters and Demos (2018).</dd>
</dl>
</section>
</footer>



</body>
</html>
